
# Building a simple workflow

Let's start with something small, something simple!

## Overview 

> A completed version of this workflow is available within the janis repo: [`janis/examples/simple.py`](https://github.com/PMCC-BioinformaticsCore/janis/blob/master/janis/examples/simple.py) 

 We have a _tar_ archive that contains a Java file. In this tutorial we're going to untar the archive, compile the result of the archive and archive the compiled and uncompiled file. The image below (generated by [Rabix Composer]([https://github.com/rabix/composer](https://github.com/rabix/composer))) gives you a good picture of how our workflow will connect.
 
![Simple workflow](resources/simple.png)

### You will need

A basic installation of janis is required (see the [Getting Started](https://janis.readthedocs.io/en/latest/tutorials/gettingstarted.html) guide for more info). You can install janis by running:
```bash
pip3 install janis-pipelines
```

## Let's get started!

We've discussed what our workflow will do, let's identify the tools we'll use to build this. All of these unix tools are bundled with the core installation of `janis`.

- [`untar`](https://janis.readthedocs.io/en/latest/tools/unix/tar.html)
- [`cat`](https://janis.readthedocs.io/en/latest/tools/unix/cat.html)
- [`tar`](https://janis.readthedocs.io/en/latest/tools/unix/untar.html)

These tools are linked to their generated documentation on this site. It's highly recommended you become familiar with this documentation website, as it is the easiest way to determine the tool's requirements.

### Setting up
 
Here's a template for our simple workflow

```python
import janis

 # tool and data_type imports go here

class Simple(janis.Workflow):
	def __init__(self):
		super().__init__(self, "simpleWorkflowIdentifier")
		# assemble our workflow here
```

### Inputs and Outputs

We only have one input, a TarFile. We'll use the type TarFile (`janis.unix.data_types.tarfile`). We can use the import statement:

```python
from janis.unix.data_types.tarfile import TarFile
```

And the declaration of our input:
```python
inp = Input("tarFile", TarFile())
```

### Steps

We'll declare all of our steps in separate lines, we can import them from the unix toolshed with the following statements:
```python
from janis.unix.tools.compile import Compile  
from janis.unix.tools.tar import Tar  
from janis.unix.tools.untar import Untar
```

We can instantiate the three steps with the following three lines, where the string is a step name or alias:
```python
step1 = Step("untar", Untar())  
step2 = Step("compile", Compile())  
step3 = Step("tar", Tar())
```


### Outputs

We know we're going to want to output the result of the Tar, hence we only need one output. Janis will automatically determine the output type, so you don't need to worry about specifying a type:

```python
outp = Output("out")
```

### Connecting edges

Given the following ASCII diagram:
```
file.tar → untar → compile → tar -> out.tar
                  ↘_______↗
```

From the documentation, we see that Untar returns a list of files (as an archive can contain multiple inputs), while compile only takes one input. `Janis` will automatically scatter the result of Untar over Tar, and will implicitly join them again in Tar (which takes an array input).

| Statement | Python |
|-------:|:-----|
| input to untar | `self.add_edge(inp, step1.tarFile)` |
| untar to compile | `self.add_edge(step1.files, step2.file)` |
| untar to tar | `self.add_edge(step1.files, step3.files)` |
| compiled to tar | `self.add_edge(step2.compiled, step3.files)` |
| tar to output | `self.add_edge(step3.tarred, outp)` |


### The final result

```python
from janis import Workflow, Input, Output, Step, File
# Data types - These help us logically connect workflows  
from janis.unix.data_types.tarfile import TarFile  
# Tools - The command line tools we're going to call  
from janis.unix.tools.compile import Compile  
from janis.unix.tools.tar import Tar  
from janis.unix.tools.untar import Untar  
  
class SimpleWorkflow(Workflow):  
    def __init__(self):  
        super().__init__("simpleWorkflow")  
        inp = Input("tarFile", TarFile())  
  
        step1 = Step("untar", Untar())  
        step2 = Step("compile", Compile())  
        step3 = Step("tar", Tar())  
  
        outp = Output("out")  
  
        self.add_edge(inp, step1.tarFile)  
        self.add_edge(step1.files, step2.file)
        self.add_edge(step1.files, step3.files)  
        self.add_edge(step2.compiled, step3.files)  
        self.add_edge(step3.tarred, outp)
```

### Export

Now that we have a workflow, it's time to export it to a representation, in this case WDL. For this example we're going to use WDL. Inside an `if __name__ == "__main__"`, we're going to create an instance of the `SimpleWorkflow` and call its `translate` method:

```python
if __name__ == "__main__":  
    SimpleWorkflow().translate("wdl")
```

In the console you'll find your exported workflow, a list of tools and a blank input file. To write this to disk, include a `to_disk=True` argument in the `.translate` method.

Here's the exported workflow (no tools):

```wdl
version development

import "tools/untar.wdl" as U
import "tools/javacompiler.wdl" as J
import "tools/tar.wdl" as T

workflow simpleWorkflow {
  input {
    File tarFile
  }
  call U.untar as untar {
    input:
      tarFile=tarFile
  }
  # This is the scatter that we discussed between untar and tar
  scatter (f in untar.files) {
     call J.javacompiler as compile {
      input:
        file=f
    }
  }
  call T.tar as tar {
    input:
      files=[untar.files, compile.compiled]
  }
  output {
    File out = tar.tarred
  }
}
```

## Finished!

Congratulations on constructing and exporting your first workflow, and i You can now get more advanced with the following tutorials:

- [Building a simple bioinformatics workflow](/tutorials/alignsortedbam)
- [Running workflows](https://janis.readthedocs.io/en/latest/tutorials/running.html)
